- [缘起——流](#缘起流)
- [css术语](#css术语)
- [流、元素与基本尺寸](#流元素与基本尺寸)
  - [块级元素](#块级元素)
    - [两个盒子](#两个盒子)
    - [width和height作用在哪个盒子上](#width和height作用在哪个盒子上)
      - [width:auto](#widthauto)
      - [width的作用细节](#width的作用细节)
    - [关于height](#关于height)
    - [min/max-width/height](#minmax-widthheight)
  - [内联元素](#内联元素)
    - [内联盒模型](#内联盒模型)
    - [struts](#struts)
- [盒尺寸四大家族](#盒尺寸四大家族)
  - [content](#content)
    - [content与替换元素](#content与替换元素)
      - [替换元素的尺寸](#替换元素的尺寸)
      - [替换元素和content](#替换元素和content)
    - [content内容生成技术](#content内容生成技术)
      - [清除浮动](#清除浮动)
      - [两端对齐](#两端对齐)
      - [content attr属性值内容生成](#content-attr属性值内容生成)
  - [padding](#padding)
    - [padding的百分比值](#padding的百分比值)
  - [margin](#margin)
    - [margin与元素尺寸以及相关布局](#margin与元素尺寸以及相关布局)
      - [元素尺寸包括：](#元素尺寸包括)
      - [margin对元素尺寸的影响](#margin对元素尺寸的影响)
    - [margin的百分比](#margin的百分比)
    - [margin合并](#margin合并)
      - [margin合并的计算规则](#margin合并的计算规则)
    - [margin: auto实现块级元素对齐](#margin-auto实现块级元素对齐)
  - [border](#border)

# 缘起——流
流，CSS世界中引导元素排列和定位的一条看不见的“水流”。
流是怎么影响css世界？
1. HTML默认表现符合“流”
2. 特殊布局和流的破坏
3. 流向的改变
流体布局有自适应性

# css术语
1. 属性：height, color
2. 值：整数值（z-index:1中的1），数值（line-height: 1.5中的1.5），百分比值（padding:50%中的50%），长度值（如99px），颜色值（#999）等等。
3. 关键字：solid，inherit等
4. 变量：currentColor
5. 长度单位：时间单位（s, ms），角度单位（deg），长度单位（px，em）
   1. 相对长度单位：em、ex、vh、vm
   2. 绝对长度单位：px
6. 功能符：url、rgba、calc、过渡效果、scale
7. 属性值：属性后面跟着的一串值
8. 声明：属性+属性值。例如：color: transparent
9. 声明块：花括号{}包裹的声明系列
10. 规则或规则集：选择器+声明块
```
.vocabulary {
  height: 99px;
  color: transparent;
}
```
11. 选择器：瞄准目标元素的东西（类选择器，ID选择器，属性选择器，伪类选择器，伪元素选择器）
12. 关系选择器：空格（后代选择器）、>（相邻后代选择器）、～（兄弟元素）、+（相邻兄弟元素）
13. 规则：@定义

# 流、元素与基本尺寸
## 块级元素
“块级元素”与display: block不是一个概念
“块级元素”基本特征是，**一个水平流上只能单独显示一个元素，多个块级元素则换行显示**
由于“块级元素”具有换行特性，因此理论上可以配合clear属性来清除浮动带来的影响
```
.clear:after {
  content: '';
  display: table; // table 也有block特性
  clear: both;
}
```
### 两个盒子
每个元素都有两个盒子，**外在盒子**和**容器盒子**，根据display的属性值不同，元素的盒子不同
* block：由外在的“块级盒子”和内在的“块级容器盒子”组成
* inline-block: **内联盒子和内在的“块级容器盒子”组成**
* inline: 内外均是“内联盒子”
### width和height作用在哪个盒子上
内在盒子
#### width:auto
4种宽度表现：
1. 充分利用可用空间 (外部尺寸特性)
2. 包裹性：浮动、绝对定位、inline-block元素、table元素 (内部尺寸特性)
3. 收缩到最小：当一列空间不够用的时候，文字能断就断。中文是随便断的，英文单词不能断 (内部尺寸特性)
4. 超出容器限制：特殊情况，如内容很长的连续的英文和数字，或内联元素被设置成了 white-space:nowrap (内部尺寸特性)

外部尺寸与流体特性
1. **正常流宽度**：在页面中随便扔一个<div>，其尺寸表现就会和这水流一样铺满容器
   ```
   a {
    display: block;
    width: 100%; // 没必要
   }
   ```
   **“外部尺寸”的块级元素一旦设置了宽度，其流动性就丢失了**
   所谓流动性，并不是看上去的宽度100%这么简单，而是margin/padding/border/content内容区域自动分配水平空间的机制
2. **格式化宽度**：格式化宽度仅出现在“绝对定位模型”中，也就是出现在position:absolute或fixed的元素中。默认情况下，绝对定位的宽度表现为包裹性。但有一种情况由外部尺寸决定：对于非替换元素，当left/top或top/bottom对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性（position值非static）的祖先元素计算

内部尺寸与流体特性
尺寸由内部元素决定。如果这个元素里面没有内容，宽度就是0，就是“内部尺寸”
3种表现：
1. 包裹性/自适应性：元素尺寸由内部元素决定，但永远小于“包含快”容器的尺寸。
包裹性有啥作用呢。
「需求」
页面某个模块的文字内容是动态的，可能是几个字，也可能是一句话。希望文字少的时候剧中显示，文字超过一行的时候居左显示。该如何实现呢？
```
.box {
  text-align: center;
}
.content {
  display: inline-block;
  text-align: left;
}
```
2. 首选最小宽度
   假设外部容器的宽度是0，元素表现的宽度是首选最小宽度
   * 东亚文字最小宽度为每个汉字的宽度
   * 西方文字最小宽度由特定的英文字符单元（空格、短横线、问好等）决定。
   * 类似图片这种替换元素的最小宽度是该元素内容本身的宽度。
实现“凹”，“凸”效果
```
// html
<div class="demo">
    <span class="ao"></span>
    <span class="tu"></span>
</div>
// css
.ao, .tu {
  display: inline-block;
  width: 0;
  color: #fff;
}
.ao:before {
  content: "love你love";
  outline: 2px solid #cd0000;
}
.tu:before {
  content: "我love你";
  outline: 2px solid #cd0000;
}
```
3. 最大宽度：最大宽度等同于“包裹性”元素设置white-space:nowrap后的宽度。如果内部没有块级元素或块级元素没有设定宽度值，则“最大宽度”实际上是最大的**连续内联盒子**（中间没有换行标签或其他块级元素）的宽度。

#### width的作用细节
width是作用在“内在盒子”上的，这个“内在盒子”又分为4个盒子，分别是content box、padding box、border box和margin box
margin的背景色永远透明，意味着元素本身的尺寸不受margin值变化而变化。因此，box-sizing的属性值不包括margin（有content-box，曾支持padding-box，border-box）。
宽度设定的弊端
1. 流动性丢失
2. 与现实世界表现不一致
因此，推从无宽度布局
「问」
一个元素，如果我们设置了width和height的值，此时如果设置margin值，其offset尺寸会有变化吗？
答案是，不会

### 关于height
 height百分比
 对于width，就算父元素width为auto，其百分比也是支持的；如果父元素height值为auto，只要子元素在文档流中，其百分比值会被忽略。因为"auto"*100%为NaN
 让height:100%生效的方式
 1. 显示设定高度值
 2. 使用绝对定位
绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于：
绝对定位元素的百分比计算是相对于**padding box**，而非绝对定位元素则是相对于**content box**计算

### min/max-width/height
用于自适应布局，兼顾还原性的同时还兼顾扩展性
```
img {
  max-width: 100%;
  height: auto !important;
}
```
height: auto是必须的，否则，如果原始图片设置了height，max-width生效的时候，图片会被水平压缩
* width/height初始值默认是auto
* max-width和max-height默认初始值是none
* min-width和min-height默认初始值是auto

当width，min-width，max-width发生冲突时
* max-width < width 且 width声明了!important，元素宽度仍取max-width
* min-width > max-width，元素宽度取min-width

「需求」
任意高度的元素展开收起动画技术
❌的实现
height+overflow:hidden
auto是个关键字，而非数值，正如height:100%的100%无法和auto相计算一样，从0px到auto也是无法计算的。
```
.element {
  height: 0;
  overflow: hidden;
  transition: height .25s;
}
.element.active {
  height: auto;
}
```
靠谱点的方式
使用max-height，将max-height设置成一个够大的值，利用其自适应性

```
.element {
  max-height: 0;
  overflow: hidden;
  transition: height .25s;
}
.element.active {
  max-height: 666px;
}
```

## 内联元素
元素的“外在盒子”主要有inline、block水平。
css世界中内联元素最为重要，涉及到的css属性最多，这些属性往往具有继承性
何为内联元素
1. “内联元素”的“内联”特指外在盒子是内联盒子
2. 在同一文档流中，可以和文字在一行显示
   
### 内联盒模型
一些术语
1. 内容区域：围绕文字看不见的盒子，其大小仅受字符本身特性控制；对于如图片这样的非替换元素，其内容区域是元素自身
2. 内联盒子：指的就是元素的外在盒子，决定元素是内联级还是块级。
3. 行框盒子：每一行就是一个行框盒子，每个行框盒子是由一个个“内联盒子”组成

### struts
> Each line box starts with a zero-width inline box with the element’s font and line
> height properties. We call that imaginary box a “strut”
每个行框盒子前面有一个宽度为0，高度由字体和行高决定的内联盒子
```
// html
<div><span></span></div>
// css
span {
  display: inline-block;// 为inline-flex，inline-grid，inline-table时候会撑开，为inline的时候不会撑开
}
```
ps: 我测试的时候发现，行框盒子包含的内联盒子display属性值为inline-block的时候，才会撑开高度；为inline的时候，不会撑开高度

# 盒尺寸四大家族
## content
### content与替换元素
替换元素：通过修改某个属性值呈现的内容就可以被替换的元素就成为“替换元素”
特性包括：
1. 内容外观不受页面上的css影响
2. 有自己的尺寸
3. css属性有自己的一套规则
> img, input, textarea, video, select...
#### 替换元素的尺寸
1. 固有尺寸是替换内容原本的尺寸
2. html尺寸：通过html原生属性改变，例如<input>的size属性，<img>的width和height
3. css尺寸：通过css的width/height/m?x-width/m?x-height设置的尺寸

计算规则
* css尺寸覆盖html尺寸，html尺寸覆盖固有尺寸
* 如果“固有尺寸”含有固有的宽高比例，同时仅设置了高度或者宽度，则元素依然按照固有的宽高比例显示
* 如果三种尺寸都没有，<canvas> <video> <iframe> 这些元素的最终表现300 * 150像素，宽高比2:1。img不同浏览器表现不一样
* 内联替换元素和块级替换元素使用上面同一套计算规则

#### 替换元素和content
替换元素和非替换元素隔了一个content 
使用content属性，普通标签元素**使用content属性生成的内容**变为替换元素
**只是视觉上的替换**
因此，具备替换元素的特性
1. 文本无法选中和复制
2. 无法左右:empty伪类；即便给<div></div>通过css添加内容，例如增加:after伪元素，该空div元素仍命中:empty伪类
3. content动态生成的值无法获取；譬如content: counter(icecream)，无法通过js获取该伪元素的呈现number类型数值，只能得到css属性值counter(icecream)

### content内容生成技术
主要是配合伪元素实现一些通用的布局
#### 清除浮动
```
.clear:after {
  content: '';
  display: block;
  clear: both;
}
```
#### 两端对齐
css3可以用flex布局，这里使用text-align:justify特性实现
```
// css
.box {
  width: 256px;
  height: 256px;
  text-align: justify; // 关键
}
.box:before {
  content: "";
  height: 100%;
  display: inline-block;
}
.box:after {
  content: "";
  display: inline-block;
  width: 100%;
}
.bar {
  display: inline-block;
  width: 20px;
}

// html
<div class="box"><i class="bar"></i>
 <i class="bar"></i>
 <i class="bar"></i>
 <i class="bar"></i>
 </div>
```
实现要点：
1. 两端对齐的关键是使用text-align:justify
2. :before伪元素是用来控制底部对齐。一个inline-block元素，如果里面没有内联元素或者overflow不是visible，则该元素的基线就是margin底边缘；否则其基线是元素里最后一行内联元素的基线。
3. :after伪元素用于辅助实现两端对齐，因为要让justify生效，需要多生成一行
这种实现的不足是，有的地方不能换行或者空格，会影响样式

#### content attr属性值内容生成
```
content: attr($属性名) //属性除了原生的html属性，也可以是自定义属性
```

## padding
>「错误的认识」
> 内联元素的padding只会影响水平方向，不会影响垂直方向
给内联元素加一个背景色或边框，就可以看到padding对元素尺寸有影响，但不影响上下元素的布局，仅仅是垂直方向发生了重叠。
内联元素的垂直方向的行为表现完全受line-height和vertical-align的影响。对于非替换的内联元素，不仅padding不会加入行盒高度的计算，margin和border也如此，都是不计算高度，但实际上在内联盒子周围发生了渲染。
利用这一特性实现的布局案例
「优雅地增加链接或按钮的点击区域大小」
```
artical a {
  padding: .25em 0;
}
```
「分隔线」
登录 ｜ 注册
```
// css
a + a:before {
  content: '';
  font-size: 0;
  padding: 10px 3px 1px;
  margin-left: 6px;
  border-left: 1px solid gray;
}
// html
<a href="">登录</a><a href="">注册</a>
```
### padding的百分比值

1. 与margin不同，padding的属性不支持负值
2. padding支持百分比，padding百分比值无论是水平方向还是垂直方向均是相对于宽度计算
3. 对于内联元素，padding会断行，其padding是跟着行框盒子走的

因此，可以实现等比矩形效果
```
// 实现矩形
div {
  padding: 50%;
}
// 实现宽高比2:1的长方形
div {
  padding: 25% 50%;
}
```
padding属性结合background-clip属性，可以实现一些css图形效果绘制
「三道杠」
```
.icon-menu {
  display: inline-block;
  width: 140px;
  height: 10px;
  border-top: 10px solid;
  border-bottom: 10px solid;
  background-clip: content-box; 
  background-color: currentColor;
}
```
「双层圆点效果」
.icon-dot {
  display: inline-block;
  width: 100px;
  height: 100px;
  border: 10px solid;
  padding: 10px;
  background-color: currentColor;
  background-clip: content-box;
  border-radius: 50%;
}
## margin
### margin与元素尺寸以及相关布局
#### 元素尺寸包括：
1. 元素尺寸：offsetWidth, offsetHeight。包括padding和border
2. 元素内部尺寸：clientWidth, clientHeight。只包括padding，不包括border
3. 元素外部尺寸：原生JS没有相关DOM API，包括margin, padding, border

#### margin对元素尺寸的影响
**内联元素**
垂直方向的margin是没有任何影响的，既不会影响外部尺寸，也不会影响内部尺寸，有种石沉大海的感觉。
水平方向，由于内联元素宽度表现为“包裹性”，也不会影响内部尺寸。
**块级元素**
1. margin与元素的内部尺寸/可视尺寸
* 元素设定了width值或者保持“包裹性”的时候，margin对元素的可视尺寸无影响；
* 元素是“充分可利用空间”状态的时候，margin才可以改变元素的可视尺寸（负margin值，拉伸；正margin值，收缩）；普通元素是按默认的水平流方向布局，因此，margin只能改变元素水平方向尺寸;对于具有拉伸特性的绝对定位元素，水平和垂直方向都有效。
「实现两栏布局」
一侧定宽条件下
```
.box {
  overflow: hidden;
}
.box > .left {
  float: left;
}
.box > .right {
  margin-left: $left-width;
}
```
2. margin与元素的外部尺寸
除了定位特性之外，我们似乎对元素的外部尺寸变化不是很敏感。
借助margin的外部尺寸特性，能实现：
「滚动底部留白」
滚动底部留白只能利用子元素的margin-bottom来实现。因为padding-bottom存在兼容性问题。如果容器可滚动，在IE/Firefox下，会忽略padding-bottom值。
「等高布局」
```
.column-box {
  overflow: hidden;
}
.column-left,.column-right {
  padding-bottom: 9999px;
  margin-bottom: -9999px;
}
```
该实现方案不足之处，父容器的overflow必须设置为hidden
### margin的百分比
* 同padding，水平和垂直方向都是相对父容器的宽度计算
* 应用价值低。margin垂直方向上无法改变元素的自身内部尺寸，并且存在margin合并
### margin合并
发生条件：
1. 块级元素
2. 垂直方向
发生场景：
1. 相邻兄弟元素

   ```
   p {
    margin: 1em 0;
   }
   <p>第一行元素</p>
   <p>第二行元素</p>
   此时，第一行元素与第二行元素之间的margin值是1em
   ```
2. 父级与第一个/最后一个子元素
   以下三种设置都是等效的
   ```
   // 第一种
   <div class="father">
    <div class="son" style="margin-top: 80px;"></div>
   </div>
   // 第二种
   <div class="father" style="margin-top: 80px;">
    <div class="son"></div>
   </div>
   // 第仨种
   <div class="father" style="margin-top: 80px;">
    <div class="son" style="margin-top: 80px;"></div>
   </div>
   ```
   表现是，margin都合并到父元素上了。
   解决margin合并的方案：
   * 块状格式化上下文
3. 空块级元素的margin合并
   ```
   .father {
    overflow: hidden;
   }
   .son {
    margin: 1em 0;
   }
   ```
   结果div元素的高度变成了1em，原因是margin-top和margin-bottom合并了。
   「问」p元素上下之间的margin是多少
   「答案」1em
   ```
   p {
    margin: 1em 0;
   }
   // html
   <p>第一行</p>
   <div></div>
   <p>第二行</p>
   ```
   即使空块级元素没有设置垂直方向的margin值，也会发生合并。
#### margin合并的计算规则
1. 正正最大值
2. 正负值相加
3. 负负最负值
### margin: auto实现块级元素对齐
margin:auto的填充规则：
1. 如果一侧定值，一侧auto，则auto为剩余空间大小
2. 如果两侧都是auto，则平分剩余空间
前提：margin: auto计算发生在元素width或height为auto时，元素对应方向具有自动填充特性。
这就是为啥垂直方向margin:auto不能实现居中的原因。
## border