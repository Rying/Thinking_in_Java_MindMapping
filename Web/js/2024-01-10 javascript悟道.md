# JS悟道

## 数值


## 异常
js编译器会为每个函数生成一个捕获图

当前函数执行到throw语句，触发一个异常 -> 询问捕获图 -> 找到catch块，该块获取控制权执行
												 -> 未找到catch块，函数调用者成为当前函数，函数抛出异常的位置继续抛出异常，当前函数询问捕获图
层层递进，如果直到栈底还没有找到catch块，就得到了一个未捕获的异常(uncaught exception)。



## 程序
微观层面的优秀程序取决于良好的编码约定，后者有助于提高优秀代码和不良代码之间的视觉差异，从而使错误更容易被发现。
宏观层面的优秀程序则取决于模块设计。


## 纯度

添加各种规范来让自己用的js变纯。
- 丢弃所有的赋值语句，只保留const语句。
- 丢弃可以修改对象内容的运算符和方法。如delete运算符，Object.assign，更改数组内容的splice(就地移除或者替换已存在的元素和/或添加新的元)和sort(就地对数组的元素进行排序，并返回对相同数组的引用)等，抛弃getter和setter（副作用）
- for语句的原始意图就是修改归纳变量，while和do也是，因此应该抛弃。尾递归才是最存粹的迭代方式。

生成器和对象都很好地隐藏了它们的状态

## 事件化编程
当程序的行为受到宇宙中的随机性所惑时，我们会非常难以重现一些问题。
在操作系统层面，线程虽然危险，确是不可或缺的；但在应用层面，就只剩危险了。js不会以这种方式来让我们使用线程，对并发更友好。

事件循环/消息循环

回合法则：
莫等待，莫阻塞，赶紧结束

任何违反回合法则的函数都应该及时被修正，或者以子进程的形式隔离到另一个进程中执行，进程和线程类似，只是它们之间不共享内存。

请求器
请求器：接收一个回调函数，执行一个单元逻辑的函数。

function my_little_requestor(callback, value)
一个callback函数应该有两个参数：value和reason。value就是请求器的执行结果，reason是一个可选参数，用于描述错误。
function my_little_callback(value, reason)
请求器函数还可以按需返回一个取消函数

我们在很多时候会用工厂来生成请求器。

## 日期
日期设计本身就是极其复杂的

getDate方法用于返回某个Date对象对应月的日子。getDay的方法，返回的是星期几
getMonth（0～11）返回结果是从0算起的，毕竟这是程序员的习惯。getDate(1~31)不是从0算起的。
务必使用getFullYear和setFullYear来规避这个错误。
Date是传统编程的糟粕，与该对象的交互应该交给事务或者其他更高阶的机制去处理。通过getter和setter直接暴露了与时间相关的底层数据。这让Date不伦不类。

ISO 8601 
2024-09-27

JavaScript使用的时间戳是从1970-01-01开始的。到2038年，32位Unix操作系统会因时间戳中的所有比特位用光且溢出而出问题。事实证明，32位不足以支撑以秒作为最小粒度的系统时钟

## 测试

膨胀：软件膨胀会引起安全方面的问题，因为可被攻击的面积变大了
平时养成多删代码的习惯。在预估开发周期时，务必为删除多余代码、淘汰有问题的依赖包预留时间。
新特性的加入有好处，但是也有成本。如果不计成本，我们早晚会为膨胀的技术债付出代价。

## 优化
性能元凶
- 无法并行化
- 违反回合法则
- 低内聚性
- 高耦合性
- 错误算法
- 缓存抖动
- 代码膨胀
- 第三方代码
