# Webpack
Webpack会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。有这个chunk得到的打包产物称为bundle
![](./webpack打包核心原理.jpg)

## 模块标准
commonjs与es6module的区别
- 最本质的区别是对模块依赖的解决是“动态”还是“静态”。commonjs是“动态”，其含义是，模块依赖关系的建立发生在代码运行阶段（require的模块路径可以动态指定）；而“静态”则是模块依赖关系的建立发生在代码编译阶段（ES6 module的导入导出语句都是声明式的，不支持导入的路径是一个表达式，并且导入、导出语句必须位于模块的顶层作用域）。
- 值拷贝与动态映射。对于commonjs来说获取的是一份值拷贝，而在es6 module中则是值的动态映射，并且这个映射是只读的，。
- 循环依赖。commonjs中的循环依赖，没法得到预期的结果。es6 module的动态映射特性可以解决支持循环依赖（需要开发保证导入的值被使用时已经设置好正确的值）

AMD异步模块定义，由javascript社区提出的专注于支持浏览器端模块化的标准。

UMD通用模块标准，是一组模块形式的集合。
(function (global, main) {
	If (typeof define .-= ‘function’ && define.amd) {
		// AMD
		define(…)
	} else if (typeof exports === ‘object’) {
		// Commonjs
		module.exports = …
	} else {
		// 非模块环境
		global.add = …
	}
})(this, function() {
 	// 定义模块主体
})

核心的数据结构：Dependency、Module、Chunk


## 流程

1)从配置中获取打包入口;
2)匹配 loader规则，并对入口模块进行转译;
3)对转译后的模块进行依赖查找(如a.js中加载了b.js和c.js);
4)对新找到的模块重复进行步骤2)和步骤3)，直到没有新的依赖模块。

lib/webpack

webpack方法
- createCompiler
- 执行compiler，compiler.run

### createCompiler方法
- 组装options
- 将配置的plugin应用于compiler
- 触发environment hook
- 触发afterEnvironment hook
- 调用WebpackOptionsApply.process方法，根据配置应用一些内置的plugin
- 触发initialize hook

### WebpackOptionsApply.process方法
- 基本配置
- 根据基本配置，将内置的一些plugin应用于compiler
    - 如果配置了externals，运用ExternalsPlugin
    - 如果配置了externalsPresets
        - node，运用NodeTargetPlugin
        - electron*，ElectronTargetPlugin
        - nwjs，ExternalsPlugin
        - ChunkPrefetchPreloadPlugin
        - 。。。
- EntryOptionPlugin应用于compiler
- 触发entryOption hook
- 触发afterPlugins hook
- 为resolveOptions增加一些hook 回调事件
- 触发afterResolvers hook


### compiler.run 方法
- 依次触发各种plugin执行，其中从EntryPlugin开始
- Compilation 构建阶段，主要是通过asyncQueue依次执行 processDependencies - addModuleQueue - factorizeQueue - buildQueue
- build阶段，loader的执行顺序。loader-runner是webpack下另一个lib。LoaderRunner.runLoaders
  - NormalModuleFactory - this.hooks.resolve.tapAsync处理了rules，根据rules的enforce配置对loaders排序。并且特殊处理了（-!, !, !!）去除符号逻辑。
  - 

￼

## 核心流程
![](./webpack.jpg)
### 创建compiler阶段 createCompiler 读取plugin挂载compiler回调事件
### 构建阶段 compiler.run
#### 由EntryPlugin开始
#### compiler.compile阶段 
      准备compilation.dependenciesFactory
#### compiler.make阶段 
      addEntry 添加入口
      递归构建模块树handleModuleCreation 
      - 构建模块
      - 添加模块 addModule 构造compilation的moduleGraph。webpack的模块有向图的处理逻辑在ModuleGraph类的setResolvedModule方法中。
      - 编译模块 buildModule

